---
layout: default
title: 对Data Race Free 的理解
categories: [科研]
comments: true
---


# 对Data Race Free 的理解

## Data Race Free 的动机
Data Race Free 是对多线程程序 **同步程度** 的一种描述，假如你的多线程程序的同步程度满足 DRF 的要求，那么，你的程序会有这样一个好处：

    程序在弱一致性模型下执行，执行的结果与在SC模型下执行一样

这意味着，程序员在写程序时，可以按SC模型来推断程序的执行。而程序在底层运行时，可以享受弱一致性模型带来的种种优化措施。

## Data Race Free 具体内容

DRF 要求多线程程序中不能有冲突的操作。

什么是冲突的操作呢？

冲突的操作是指：两个操作来自不同线程，操作同一地址，至少有一个是写操作。

如何让冲突的操作不冲突呢？

需要使用同步操作将冲突的操作隔离开。

为什么要用同步操作将冲突的操作隔离开呢?




因为如果不隔离开，程序在弱一致性模型下执行的结果就和在SC模型下执行的结果不一样了。这意味着如果你用SC模型推断程序执行结果，而程序又运行在弱一致性模型下，那么程序的真正结果可能和你推断的不一样。

那么，又为什么：如果不隔离开，程序在弱一致性模型下执行结果就和SC模型下不一样了呢？

这个问题其实在问：为什么隔离会使得程序在弱一致性模型下执行结果与SC模型下执行结果一致？

这个问题用一句话来回答是：隔离使得我们可以找到所有操作的一种全序，而这种全序正是SC所需要的。



从上图可以看出，同步操作将相互冲突的操作隔离开，这种隔离为原本无序的多线程程序添加了一些顺序：

* 同步操作之间有顺序了
* 同步操作与其之前的所有操作之间有顺序了
* 同步操作与其之后的所有操作之间有顺序了

这些顺序保证了程序在弱一致性模型下与在SC模型下执行结果一样。

另外，我们还发现，有些操作之间并没有顺序保证，这正是DRF的优势所在，这些无须顺序保证的操作可以在弱一致性模型下得到优化，同时他们的无序又不会使得执行结果与SC下有任何不同。

如果我们想找一个所有操作之间的全序，只需要在这些无须保证顺序的操作中随便选择一个顺序，另外，还需要保证那些因为同步而添加的顺序关系。如此构成一个全序。这个全序正是SC模型所需要的。

由此，我们也明白了DRF的精髓:

    只保证必要的顺序，不保证不必要的顺序。

所谓必要是指，保证这些顺序就可以使得程序在弱一致性模型下的执行结果与SC模型下的执行结果一致，不保证就不行。
